use no_std_io::Reader;
use safe_transmute::TriviallyTransmutable;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Spawn {
    data: [u8; Self::DATA_SIZE],
}

impl Spawn {
    pub const DATA_SIZE: usize = 0x38;

    pub fn get_seed(&self) -> u64 {
        self.default_read_le(0x20)
    }
}

impl Default for Spawn {
    fn default() -> Self {
        Self {
            data: [0; Self::DATA_SIZE],
        }
    }
}

impl Reader for Spawn {
    fn get_slice(&self) -> &[u8] {
        &self.data
    }
}

unsafe impl TriviallyTransmutable for Spawn {}

#[cfg(test)]
mod test {
    use super::*;

    const SPAWN: Spawn = Spawn {
        data: [
            0x9d, 0x54, 0x0f, 0x44, 0x15, 0xae, 0xf7, 0x41, 0x08, 0xd0, 0x21, 0x44, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x2c, 0xbe, 0x00, 0x00, 0x00, 0x00,
            0x8b, 0x5c, 0x7c, 0x3f, 0x3e, 0x46, 0xf2, 0xdb, 0x91, 0x7d, 0xbe, 0x5c, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x98, 0x3f, 0x42,
        ],
    };

    #[test]
    fn should_get_seed() {
        assert_eq!(SPAWN.get_seed(), 0x5cbe7d91dbf2463e)
    }
}
